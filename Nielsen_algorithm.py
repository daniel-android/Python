mport matplotlib.pyplot as plt 
import numpy as np 
import math 
import time

#This algorithm reseives a finite set U of words on {a,b} and computes
# a Nielsen reduced set which is a free basis for a free group.

#G.<a,b> = FreeGroup(); #free grouop generated by a and b

############# INPUT #############################################
#Input U a possible free basis for a subgroup of G
# a |---> 1        b |---> 2

U= [[1, 2], [1, 1, 2, 2,-2,-1], [1, 1, 1, 2, 2, 2,-2,-1], [1, 1, 1, 1, 2, 2, 2, 2,-2,-1]]



#FIRST PRINTING
print('Given basis U=', U)


############## FUNCTIONS ##########################################
####### Function for reducing a word

def func1(list):
	i=0;
	for j in range(0,len(list)):
		#print(type(list))
		if (j+1<len(list)) and (list[j]+list[j+1]==0):
			del list[j]
			del list[j]
			i=1;#some change was made in the list
		if i==1:
			return True,list #the return statement ends function execution
	if i==0:#no change was made (the word is already reduced)
		return False,list

def reducing_a_word(list):
	#list=list0.copy()
	flag=True;
	while flag == True:#Reducing the word
		flag, list =func1(list);
	return list


###### Function for inverting a word
def inverting_a_word(list):
	#list=list0.copy()
	list.reverse()
	for i in range(0,len(list)):
		if list[i]==1:
			list[i]=-1;
			continue
		if list[i]==-1:
			list[i]=1;
			continue
		if list[i]==2:
			list[i]=-2;
			continue
		if list[i]==-2:
			list[i]=2;
			continue
	return list	

################# MAIN ALGORITHM #########################################


####### PART 1 

#Reducing the words and deleting the empty words from the list U

A=True;
i=0;
while A==True:
	v_=U[i].copy()
	v=reducing_a_word(v_);
	v_=v.copy()
	vinv = inverting_a_word(v_);
	if len(v)==0:# the empty list has length 0
		del U[i];
		#hold the value of i since we deleted U[i] from U, the next sublist U[i+1] has index i=i+1-1 now
	elif len(v)<=len(vinv): #U[i] receives the word of minimum length in {v,vinv} 
		U[i]=v;
		i=i+1;
	else:
		U[i]=vinv;
		i=i+1;

	if i+1>len(U):
		A=False;

#SECOND PRINTING
print('After reducing and deleting empty words U=', U)


####### PART 2

def part2(U):
	B=False
	for i in range(0,len(U)):
		for j in range(0,len(U)):
			for epsilon in [1,-1]:
				v_=U[i].copy();
				if epsilon==-1:##################### epsilon
					vi=inverting_a_word(v_);
				else:
					vi=v_;
				
				v_=U[j].copy()
				for eta in [1,-1]:###################### eta
					if eta==-1:
						vj=inverting_a_word(v_);
					else:
						vj=v_;
								 ###################
					
					v= vi+vj;#concatenating two lists
					v_=v.copy();
					v=reducing_a_word(v_);
					v_=v.copy()
					vinv = inverting_a_word(v_);
					v_=vinv.copy()
					vinv=reducing_a_word(v_)

					if i!=j and len(v)<len(vi):
						B=True;
						if (len(v)==0):# the empty list has length 0
							#print(U)
							del U[i];
							return B
						elif (len(v)<=len(vinv)): #U[i] receives the word of minimum length in {v,vinv} 
					#		print(U)
							U[i]=v;
							return B
						else:
					#		print(U)
							U[i]=vinv;
							return B

B=True;
while B==True:
	B=part2(U);

####### PART 3


A=True
Ucopy=U.copy()
while A==True:
	print(Ucopy)
	A=False;
	#identifying the shortest list
	if len(Ucopy)==0:# the empty list has length 0
		#print('After part (3):')
		print('Test if the set U=', U ,' is a Nielsen reduced (apply the Nielsen test algorithm to test its reducibility).')
		break#stops the while loop
	else:
		U_shorts_list=min(Ucopy, key=len);
	#spliting (if possible)  the shortest list into two sublists of equal length
	flash=1
	if ((len(U_shorts_list)%2) == 0):
		half = len(U_shorts_list)//2
		p=U_shorts_list[:half]#p in the step (3) of the algorithm
		qinv=U_shorts_list[half:]#q^-1 in the step (3) of the algorithm
		
		v_=p.copy()
		pinv= inverting_a_word(v_);#p^-1 in the step (3) of the algorithm

		v_=	qinv.copy();
		q=inverting_a_word(v_);#q in the step (3) of the algorithm

		#cheking if there exists some U[i]=qc^-1 or U[i]=cq^-1
		for i in range(0,len(U)):
			len_q=len(q)#length of q
			len_qinv=len(qinv)#length of qinv
			if U[i]!=U_shorts_list and len_q<len(U[i]):
				#checking if q or q^-1 are initial or final segments of U[i]
				if U[i][:len_q]==q or U[i][-len_qinv:]==qinv:# is there any U[i]=qc^-1 or U[i]=cq^-1
					flash=0
					break #stops the for loop

		#I want to get the word c or c^-1
		if flash==0 and U[i][:len_q]==q:#then we have that U[i]=qc^-1
			v_=U[i].copy()
			del v_[:len_q]
			cinv=v_
			#checking for the minimum length word in {pc^-1,cp^-1}
			w1=reducing_a_word(p+cinv)
			v_=w1.copy()
			w2=inverting_a_word(v_)
			if len(w1)<=len(w2):
				U[i]=w1
			else:
				U[i]=w2
			#calling the part (2)
			B=True;
			while B==True:
				B=part2(U);
			
			#we will have to restart the part (3) again
			A=True
			Ucopy=U.copy()	

		elif flash==0 and U[i][-len_q:]==qinv:#then we have that U[i]=cq^-1
			v_=U[i].copy()
			del v_[-len_qinv:]
			c=v_
			#checking for the minimum length word in {pc^-1,cp^-1}
			w1=reducing_a_word(c+pinv)
			v_=w1.copy()
			w2=inverting_a_word(v_)
			if len(w1)<=len(w2):
				U[i]=w1
			else:
				U[i]=w2
			B=True;
			while B==True:
				B=part2(U);
			
			#we will have to restart the part (3) again
			A=True
			Ucopy=U.copy()

	if flash==1:#we still didnt find a shortest word satisfying the conditions in (3)
		Ucopy.remove(U_shorts_list)#removing the 
		#we dont have to restart the part (3)
		A=True

